const StyleDictionary = require('style-dictionary');
const transformer = StyleDictionary.transform['attribute/cti'].transformer;

// Excludes/Includes tokens based on category
const tokenFilterExclude = (cat) => (token) => token.path[0] !== cat;
const tokenFilterInclude = (cat) => (token) => token.path[0] === cat;

const propertiesToCTI = {
	width: { category: 'size', type: 'dimension' },
	'min-width': { category: 'size', type: 'dimension' },
	'max-width': { category: 'size', type: 'dimension' },
	height: { category: 'size', type: 'dimension' },
	'min-height': { category: 'size', type: 'dimension' },
	'max-height': { category: 'size', type: 'dimension' },
	'border-width': { category: 'size', type: 'border', item: 'width' },
	'border-radius': { category: 'size', type: 'border', item: 'width' },
	'border-color': { category: 'color', type: 'border' },
	'background-color': { category: 'color', type: 'background' },
	color: { category: 'color', type: 'font' },
	'text-color': { category: 'color', type: 'font' },
	padding: { category: 'size', type: 'padding' },
	'padding-vertical': { category: 'size', type: 'padding' },
	'padding-horizontal': { category: 'size', type: 'padding' },
	icon: { category: 'content', type: 'icon' },
	'font-size': { category: 'size', type: 'font' },
	'line-height': { category: 'size', type: 'line-height' },
	size: { category: 'size', type: 'icon' },
	space: { category: 'space', type: 'space' }
};

const CTITransform = {
	type: `attribute`,
	transformer: (prop) => {
		// Only do this custom functionality in the 'component' or 'semantic' top-level namespace.
		if (prop.path[0] === 'component' || prop.path[0] === 'semantic') {
			// When defining component tokens, the key of the token is the relevant CSS property
			// The key of the token is the last element in the path array
			return propertiesToCTI[prop.path[prop.path.length - 1]];
		} else {
			// Fallback to the original 'attribute/cti' transformer
			return transformer(prop);
		}
	}
};

// We can call .registerTransform here
// or apply the custom transform directly in the configuration below
//
// StyleDictionary.registerTransform({
//   name: 'attribute/cti',
//   type: 'attribute',
//   transformer: CTITransform.transformer
// });

module.exports = {
	// Rather than calling .registerTransform() we can apply the new transform
	// directly in our configuration. Using .registerTransform() with the same
	// transform name, 'attribute/cti', would work as well.
	transform: {
		// Override the attribute/cti transform
		'attribute/cti': CTITransform
	},
	source: ['src/lib/metal/tokens/tokens/**/*.json'],
	platforms: {
		core: {
			// We can still use this transformGroup because we are overriding
			// the underlying transform
			// We'll filter out the component tokens so only the core set compiles as SCSS

			// 
			transformGroup: 'scss',
			prefix: 'm',
			buildPath: 'src/lib/metal/tokens/build/',
			files: [
				{
					filter: tokenFilterExclude('component'),
					destination: '_tokens.core.scss',
					format: 'scss/variables'
				},
				{
					filter: tokenFilterExclude('component'),
					destination: '_tokens.maps.scss',
					format: 'scss/map-deep',
					mapName: 'coreMaps'
				}
			]
		},
		semantic: {
			// We can still use this transformGroup because we are overriding
			// the underlying transform
			transformGroup: 'scss',
			buildPath: 'src/lib/metal/tokens/build/',
			files: [
				{
					filter: tokenFilterInclude('semantic'),
					destination: '_tokens.semantic.scss',
					format: 'css/variables'
				}
			]
		}
		components: {
			// We can still use this transformGroup because we are overriding
			// the underlying transform
			transformGroup: 'scss',
			buildPath: 'src/lib/metal/tokens/build/',
			files: [
				{
					filter: tokenFilterInclude('component'),
					destination: '_tokens.component.scss',
					format: 'css/variables'
				}
			]
		},
		json: {
			transformGroup: 'js',
			buildPath: 'src/lib/metal/tokens/build/',
			files: [
				{
					filter: tokenFilterExclude('component'),
					destination: 'tokens.core.json',
					format: 'json/nested'
				},
				{
					filter: tokenFilterInclude('component'),
					destination: 'tokens.component.json',
					format: 'json/nested'
				}
			]
		}
	}
};
